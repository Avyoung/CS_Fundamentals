# 浅析TCP协议

[TOC]

# 一、TCP简介

## 1、TCP与UDP

TCP与UDP作为运输层的协议，经常被用来比较，它们有着各自的特点。

**UDP**是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。

* UDP是无连接的，因此在两个进程通信前没有握手过程。
* UDP提供不可靠的数据传送服务。
* UDP也不保证输出顺序。




**TCP**是因特网运输层的面向连接的可靠的运输协议，主要有一下几个特点

1. 面向连接的服务：在应用层的数据报开始流动之前，TCP让客户和服务器之间相互交换运输层控制信息。在握手阶段后，一个TCP连接就在两个进程的套接字之间建立了。而且这条接连是全双工的。
2. 可靠的数据传送服务：通信进程能够依靠TCP**无差错、按适当顺序**交付所有发送的数据。
3. TCP还具有拥塞控制机制，这种机制虽然不一定能为通信进程带来直接好处，但能为因特网带来整体好处。



## 2、TCP报文

 ![pic3](https://github.com/Yojob/CS_Fundamentals/blob/master/ComputerNetwork/pic/pic3.png?raw=true)

上图为TCP报文段结构，一般TCP的首部是20个字节，而UDP只有8个字节。

具体的含义不用每个都知道，了解几个比较常用的就可以了。

### 源端口与目的端口

主要用于多路复用与分解

### 序号和确认号

序号和确认号TCP报文段首部中两个最重要的字段，它们是TCP可靠传输的关键部分。

序列号用来标识TCP发端向TCP收端发送的数据字节流。

确认号只有在ACK标志位为1的时候才有效。同时，它也表示从期望接收端接收的下一个字节的序列号

### 标志字段

ACK用于指示确认号是有效的，即该报文包括一个对已被接收报文段的确认。

RST、SYN、FIN用于连接建立和拆除，也就是三次握手和四次挥手。



# 二、连接管理



## 1、三次握手

接下来就是最著名的TCP三次握手

 ![pic4](https://github.com/Yojob/CS_Fundamentals/blob/master/ComputerNetwork/pic/pic4.png?raw=true)



* **第一步：** 客户端TCP向服务器发送一个特殊的TCP报文。该报文不含应用层数据，但有两个关键信息。将首部中一个标志位SYN置为1，因此称此报文段为SYN报文段。另外，客户端会随机选取（为了避免安全性攻击）一个初始序列号client_isn，一起发送给服务器端。

* **第二步：** 服务器端接收到该SYN报文段后，就会分配TCP缓存和变量（没错，在三次握手完成之前就会分配缓存和变量，这也使得TCP容易遭受SYN洪泛攻击），然后返回一个也是不含应用层信息的报文段。

  这个报文段包含三个重要信息：首先，SYN比特位被置为1。其次，报文段的确认号字段被置为client_isn+1。最后，服务器选择自己的初始序列号server_isn。这个报文段被称为SYNACK报文段。

* **第三步：** 在收到SYNACK报文段后，客户端也开始分配缓存和变量，然后再向服务器发送最后一个确认报文段。因为连接已经建立，所以SYN会置为0，然后将server_isn+1作为确认号字段。



## 2、SYN洪泛攻击

**攻击原理：**

SYN Flood是当前最流行的DoS（拒绝服务攻击）与DDoS（分布式拒绝服务攻击）的方式之一，这是一种利用TCP协议缺陷，发送大量伪造的TCP连接请求，常用假冒的IP或IP号段发来海量的请求连接的第一个握手包（SYN包），被攻击服务器回应第二个握手包（SYN+ACK包），因为对方是假冒IP，对方永远收不到包且不会回应第三个握手包。导致被攻击服务器保持大量SYN_RECV状态的“半连接”，并且会重试默认5次回应第二个握手包，塞满TCP等待连接队列，资源耗尽（CPU满负荷或内存不足），让正常的业务请求连接不进来。



**防御手段：**

一种比较有效的防御手段就是SYN cookie。

* 当服务器收到一个SYN请求时，它并不知道这个请求是合法的还是攻击的，所以它不会直接分配缓存和变量。而是生成一个初始的TCP序列号，该序列号由SYN请求报文段的源和目的IP与端口号以及仅有服务器知道的秘密数经过一个复杂的哈希函数计算而成。这个被精心计算出来的序列号就被称为“cookie”，服务器将含有这个cookie的SYNACK分组返回给客户端。

* 如果客户是合法的，那么它将会返回一个ACK报文段。服务器收到ACK后需要验证它与前面的某个SYN是对应的，这时就要用到上面的cookie了。

  一个合法的ACK的确认字段，肯定是服务器返回的SYNACK中序号字段（就是上面计算出来的cookie）的值+1。所以服务器只需要再次根据源和目的IP与端口号按照上面的方法计算出cookie，因为源和目的IP与端口号没有改变，所以计算出来的cookie肯定与上面的相同，如果这个cookie值+1与ACK报文段中的确认字段相等，你们服务器就认为该ACK对应于前面的SYN，因此它是合法的。然后生成一个具有套接字的全开连接。

  如果客户是非法的也就是没有返回ACK报文段，那么服务器也并没有为它分配任何资源。

  ​

## 3、为什么是三次不是两次

直接引用谢希仁版《计算机网络》中的例子:

> “已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送ack包。



## 4、四次挥手

接下来看一下TCP断开连接的过程，需要注意的一点是下图中的客户端与服务器不是绝对的，实际情况中任何一端都可以请求中断，我们习惯把先请求中断的叫做客户端。

 ![pic5](https://github.com/Yojob/CS_Fundamentals/blob/master/ComputerNetwork/pic/pic5.png?raw=true)

* 首先，客户端发送一个特殊的报文段，将首部中的FIN标志位置为1，说明客户端已经没有数据要发送了。该报文段也叫FIN报文段。
* 服务器接受到FIN报文段后，回复一个确认报文段。但是服务器仍然可以向客户端发送数据。
* 当服务器也没有数据要发送了，就会同样向客户端发送一个FIN报文段。
* 最后，客户端对这个FIN报文段进行确认，在上图中可以看到，客户端发送ACK后没有直接关闭，而是计时等待一段时间后再关闭。最后，两台主机上的所有资源都被释放了。




整个过程Client端所经历的状态如下：



 ![pic7](https://github.com/Yojob/CS_Fundamentals/blob/master/ComputerNetwork/pic/pic7.png?raw=true)



而Server端所经历的过程如下：

 ![pic6](https://github.com/Yojob/CS_Fundamentals/blob/master/ComputerNetwork/pic/pic6.png?raw=true)



**关于计时等待**

在第四步中，客户端发送ACK报文段后会进入TIME_WAIT状态，这是因为如果客户端的ACK如果丢失了，它将重新发送，TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。



## 5、为什么是四次挥手三次握手

因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。



# 三、流量控制



## 1、作用



## 2、原理



# 四、拥塞控制



## 1、如何控制发送速率



## 2、如何感知网络拥堵



## 3、控制速率算法



# 五、TCP安全与SSL





# 六、参考地址

<http://blog.csdn.net/whuslei/article/details/6667471/>





